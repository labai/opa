package com.github.labai.opa.sys;

import com.github.labai.opa.OpaServer.RunResult;
import com.github.labai.opa.sys.AppServer.RequestIdProvider;
import com.github.labai.opa.sys.Exceptions.OpaSessionTimeoutException;
import com.github.labai.opa.sys.Exceptions.OpaStructureException;
import com.progress.common.ehnlog.IAppLogger;
import com.progress.open4gl.Open4GLException;
import com.progress.open4gl.ResultSetHolder;
import com.progress.open4gl.dynamicapi.IPoolProps;
import com.progress.open4gl.dynamicapi.MetaSchema;
import com.progress.open4gl.dynamicapi.ParameterSet;
import com.progress.open4gl.dynamicapi.ResultSet;
import com.progress.open4gl.dynamicapi.RqContext;
import com.progress.open4gl.javaproxy.AppObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;
import java.util.Map;

/**
 * @author Augustus
 *
 * For internal usage only (is not part of api)
 *
 */
class JavaProxyImpl extends AppObject {
	private final static Logger logger = LoggerFactory.getLogger(JavaProxyImpl.class);

	private RequestIdProvider requestIdGenerator = null;

	public JavaProxyImpl(String s, IPoolProps ipoolprops, IAppLogger iapplogger) throws Open4GLException {
		super(s, ipoolprops, iapplogger, null);
	}

	// procName can be null, but then annotation @OpaProc must have "proc" parameter
	//
	public RunResult runProc(Object opp, String procName, RequestIdProvider requestIdProvider) throws Open4GLException, SQLException, OpaStructureException, OpaSessionTimeoutException {

		if (!isSessionAvailable())
			throw new OpaSessionTimeoutException();

		// read bean and fill params
		//
		ParameterSet paramSet;
		try {
			paramSet = ParamUtils.beanToParam(opp);
		} catch (IllegalAccessException e) {
			throw new OpaStructureException("Error while reading bean", e);
		}

		MetaSchema metaschema = TableUtils.extractMetaSchema(opp.getClass());

		// run procedure
		//
		if (procName == null) {
			procName = ParamUtils.getProcName(opp.getClass());
			if (procName == null || "".equals(procName))
				throw new OpaStructureException("OpenEdge procedure name must be provided");
		}

		long startTs = System.currentTimeMillis();

		String requestId = generateAndSetRequestId(requestIdProvider);

		RqContext rqcontext;
		if (metaschema != null) {
			rqcontext = runProcedure(requestId, procName, paramSet, metaschema);
		} else {
			rqcontext = runProcedure(requestId, procName, paramSet);
		}

		if (System.currentTimeMillis() - startTs > 5000)
			logger.debug("Opa call to proc '{}' took {}ms", procName, System.currentTimeMillis() - startTs);

		// assign results (ordinary params) to bean; return rsmap - list of resultSets, which will be filled later
		//
		Map<Field, ResultSetHolder> rsmap;
		try {
			rsmap = ParamUtils.paramToBean(paramSet, opp);
		} catch (IllegalAccessException | InvocationTargetException e) {
			throw new OpaStructureException("Error while assigning params to bean", e);
		}

		// results
		// according generated javaProxy, we require to setRqContext for last OUT/INOUT resultSet
		if (rqcontext != null) {
			if (!rqcontext._isStreaming()) {
				rqcontext._release();
			} else {
				// last
				ResultSetHolder lastRsh = null;
				for (Field f : rsmap.keySet()) {
					lastRsh = rsmap.get(f);
				}
				ResultSet resultset = null;
				if (lastRsh != null)
					resultset = (ResultSet) lastRsh.getResultSetValue();
				if (resultset != null)
					resultset.setRqContext(rqcontext);
			}
		}

		String returnVal = (String) paramSet.getProcedureReturnValue();

		// fill all lists from resultSet (from rsmap)
		//
		TableUtils.copyAllRecordSetsToBean(rsmap, opp);

		return new RunResultImpl(returnVal, requestId);
	}

	public void setRequestIdGenerator(RequestIdProvider requestIdGenerator) {
		this.requestIdGenerator = requestIdGenerator;
	}

	// requestId as runProcedure() parameter works well in Classic app server, but doesn't in Pacific. Function on OE side was:
	// 		session:current-request-info:RequestId
	// As workaround we will use ClientContextID for requestId. In this case in OE side it can be taken using function:
	//		session:current-request-info:ClientContextId
	private String generateAndSetRequestId(RequestIdProvider runReqIdProvider) {
		String requestId = null;
		RequestIdProvider idProvider = runReqIdProvider != null ? runReqIdProvider : requestIdGenerator;
		if (idProvider != null) {
			try {
				requestId = idProvider.get();
				// also set as clientContextId (for idProvider ids only)
				this.m_properties.setStringProperty(AppServer.PROGRESS_PROPS_KEY_CONTEXT_ID, requestId);
			} catch (Throwable e) {
				requestId = newRequestID(this.m_properties);
				logger.warn("Cannot generate requestId, use generated by OE ({}). Exception: {}", requestId, e.getMessage());
			}
		}
		if (requestId == null)
			requestId = newRequestID(this.m_properties); // from oe lib

		return requestId;
	}

	private static class RunResultImpl implements RunResult {
		private final String returnValue;
		private final String requestId;
		public RunResultImpl(String returnValue, String requestId) {
			this.returnValue = returnValue;
			this.requestId = requestId;
		}
		@Override public String returnValue() { return returnValue; }
		@Override public String requestId() { return requestId; }
	}
}
